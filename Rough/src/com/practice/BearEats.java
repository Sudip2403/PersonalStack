package com.practice;

import java.util.Comparator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.TreeMap;

/**
 * Bear Limak and deer Evil have N cookies with various flavors. Cookies are numbered 0 through N-1. Bears 
 * and deer are natural enemies so Limak and Evil don't want to eat together. They decided to divide cookies by 
 * playing a simple game. They will alternately take one cookie. Limak starts. The game ends when there are no more cookies.



As you can guess, bears and deer prefer different flavors. The i-th cookie has value A[i] for Limak and 
value B[i] for Evil. We define Limak's score as sum of A[i] of his cookies and Evil's score as sum of B[i] of his cookies.



Limak knows his opponent's strategy. Evil always takes a cookie with the biggest B[i]. 
In case of tie he takes a cookie with the biggest A[i] (from cookies with the biggest B[i]).



Limak wants to maximize the difference between his and Evil's score. 
Help him and find the maximum possible value of L-E, where L denotes Limak's score and E denotes Evil's score.



The description of cookies is provided in the form of a pseudorandom generator. 
You are given the ints N, R, C, D, A_MAX, and B_MAX. As defined above, N is the number of cookies. 
The flavors of cookies are generated by the pseudocode below. Watch out for integer overflow when implementing it.



for i between 0 and N-1, inclusive:
    R = (C * R + D) modulo (10^9+7);
    A[i] = R % A_MAX;
    R = (C * R + D) modulo (10^9+7);
    B[i] = R % B_MAX;


Note that A[i] will be between 0 and A_MAX-1, inclusive. And B[i] will be between 0 and B_MAX-1, inclusive.

 
Definition
    	
Class:	BearEats
Method:	getDifference
Parameters:	int, int, int, int, int, int
Returns:	long
Method signature:	long getDifference(int N, int R, int C, int D, int A_MAX, int B_MAX)
(be sure your method is public)
    
 
Notes
-	N will be between 1 and 200,000, inclusive.
-	R, C and D will be between 0 and 1,000,000,000, inclusive.
-	A_MAX and B_MAX will be between 1 and 1,000,000,000, inclusive.
 
Examples
0)	
    	
3
4
4
1
11
15
Returns: -3
A = {6,2,4}, B = {9,14,4}. Limak should take the second cookie - (2,14). It has value A[i]=2 for him. 

Evil wants a cookie with the bigest B[i] so he takes (6,9). Limak can take the last cookie (4,4) and his score is 2+4=6. Evil's score is 9 so difference is 6-9 = -3. 
Limak can't achieve a better difference.
1)	
    	
5
2
3
0
14
40
Returns: 4
A = {6, 12, 10, 6, 12}, B = {18, 2, 18, 2, 18}. Optimal start for Limak is to take the cookie (12,18). There are two cookies with the biggest B[i] now and Evil takes the
 one with bigger A[i] - (10, 18). Limak takes (6,18), Evil (12,2) and Limak (6,2). Limak has score 12+6+6 = 24. Evil has score 18+2 = 20.
2)	
    	
4
938593858
538591850
384025833
885912358
3405
Returns: 1452754016
A = {224250140, 715072124, 737687500, 357608742}, B = {2859, 908, 1144, 2749}. Evil wants first cookie and the last one and Limak should allow him to do it. 
Limak ends with score 737687500 + 715072124 and Evil with 2859 + 2749.
3)	
    	
200000
999998741
999997411
64592149
57
75
Returns: 462494

 */
public class BearEats {

	public static void main(String[] args) {
		System.out.println(getDifference(3,4,4,1,11,15));
	}
	
	static long getDifference(int N, int R, int C, int D, int A_MAX, int B_MAX){
		Integer[] A = new Integer[N];
		Integer[] B = new Integer[N];
		for (int i = 0; i <= N-1; i++) {
			R = (C * R + D) % (1000000000+7);
		    A[i] = R % A_MAX;
		    R = (C * R + D) % (1000000000+7);
		    B[i] = R % B_MAX;
		}
		
		Map<Integer, Integer> BMap = new TreeMap<>(new Comparator<Integer>() {
			@Override
			public int compare(Integer o1, Integer o2) {
				return o2.compareTo(o1);
			}
		});
				
		for (int i = 0; i < B.length; i++) {
			BMap.put(B[i], i);
		}
	
		return calc(A, A, BMap, BMap, Long.MIN_VALUE, 0, 0);
		
	}
	
	static long calc(Integer[] A, Integer[] AC, Map<Integer, Integer> BMap, Map<Integer, Integer> BMapAC, long diff, long Ascore, long Bscore){
		if(null == A || (null != A && A.length == 0) || BMap.size() < 1) {
			return Math.max(diff, Ascore-Bscore);
		}
		
		for (int i = 0; i < A.length; i++) {
			if(null != A[i]){
				Ascore += A[i];
				A = alterA(A, i);
				BMap = alterB(BMap, i);
				
				for (Entry<Integer, Integer> entry : BMap.entrySet()) {
					Bscore += entry.getKey();
					A = alterA(A, entry.getValue());
					BMap = alterB(BMap, entry.getValue());
					break;
				}
				diff = calc(A, AC, BMap, BMapAC, diff, Ascore, Bscore);
			}
		}
		A = actualA(AC);
		BMap = actualB(BMapAC);
		return diff;
	}
	
	static Integer[] actualA(Integer[] AC){
		Integer[] A1 = new Integer[AC.length];
		for (int j = 0; j < AC.length; j++) {
			A1[j] = AC[j];
		}
		return A1;
	}
	
	static Map<Integer, Integer> actualB(Map<Integer, Integer> BMapAC){
		Map<Integer, Integer> BMap1 = new TreeMap<>(new Comparator<Integer>() {
			@Override
			public int compare(Integer o1, Integer o2) {
				return o2.compareTo(o1);
			}
		});
		BMap1.putAll(BMapAC);
		return BMap1;
	}
	
	static Integer[] alterA(Integer[] A, int i){
		Integer[] A1 = new Integer[A.length-1];
		int c = 0;
		for (int j = 0; j < A.length; j++) {
			if(i != j){
				A1[c] = A[j];
				c++;
			}
		}
		return A1;
	}
	
	static Map<Integer, Integer> alterB(Map<Integer, Integer> BMap, int i){
		Map<Integer, Integer> BMap1 = new TreeMap<>(new Comparator<Integer>() {
			@Override
			public int compare(Integer o1, Integer o2) {
				return o2.compareTo(o1);
			}
		});
		
		for (Entry<Integer, Integer> entry : BMap.entrySet()) {
			if(entry.getValue() < i) {
				BMap1.put(entry.getKey(), entry.getValue());
			}else if(entry.getValue() > i) {
				BMap1.put(entry.getKey(), entry.getValue()-1);
			}
		}
		return BMap1;
	}
}









